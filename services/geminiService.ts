
import { GoogleGenAI, Type } from "@google/genai";
import { stripBase64Prefix } from "./utils";

// =================================================================================
// TODO: è¯·åœ¨æ­¤å¤„å¡«å…¥æ‚¨æä¾›çš„ API Base URL
// 1. å¦‚æœä½¿ç”¨å®˜æ–¹ Keyï¼Œæ­¤åœ°å€ä¼šè¢«è‡ªåŠ¨å¿½ç•¥ã€‚
// 2. å¦‚æœä½¿ç”¨æ¸ é“ Keyï¼Œè¯·ç¡®ä¿æ­¤åœ°å€æ˜¯å…¼å®¹ Gemini æ ¼å¼çš„ (ä¾‹å¦‚ /v1beta/models...)
//    æ³¨æ„ï¼šOpenAI æ ¼å¼çš„åœ°å€ (v1/chat/completions) æ˜¯ä¸è¢« GoogleGenAI SDK æ”¯æŒçš„ã€‚
const VENDOR_BASE_URL = 'https://generativelanguage.googleapis.com'; 
// =================================================================================

// Helper to get fresh instance with priority on LocalStorage Custom Key
export const getApiKey = () => {
  const customKey = localStorage.getItem('SCW_API_KEY');
  const envKey = process.env.API_KEY;
  // æ ¸å¿ƒé€»è¾‘ï¼šå¦‚æœæœ‰ customKeyï¼ˆå“ªæ€•æ˜¯ä¹±å¡«çš„ï¼‰ï¼Œä¼˜å…ˆè¿”å› customKey
  // åªæœ‰å½“ customKey ä¸º null/ç©ºå­—ç¬¦ä¸²æ—¶ï¼Œæ‰å›é€€åˆ° envKey
  return customKey || envKey;
};

const getAI = () => {
  const apiKey = getApiKey();
  const customKey = localStorage.getItem('SCW_API_KEY');
  
  // --- DEBUG START: æ‰“å°å¯†é’¥ä¿¡æ¯å¸®åŠ©æ’æŸ¥é—®é¢˜ ---
  console.group('%c[Gemini Service Debug]', 'color: #C41E3A; font-weight: bold; padding: 4px; border: 1px solid #C41E3A; border-radius: 4px;');
  console.log(`Time       : ${new Date().toLocaleTimeString()}`);
  
  if (customKey) {
    console.log(`Key Source : ğŸ”´ ç”¨æˆ·è‡ªå®šä¹‰ (localStorage)`);
    console.log(`Raw Value  : "${customKey}"`);
  } else {
    console.log(`Key Source : ğŸŸ¢ ç³»ç»Ÿé»˜è®¤ (process.env)`);
  }
  
  const maskedKey = apiKey ? `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 4)}` : 'NULL';
  console.log(`Active Key : ${maskedKey}`);
  
  const options: any = { apiKey };
  
  // æ™ºèƒ½åˆ†æµé€»è¾‘
  if (apiKey && !apiKey.startsWith('AIza')) {
    console.log(`Routing    : ğŸ”€ æ£€æµ‹åˆ°éå®˜æ–¹ Keyï¼Œå°è¯•ä½¿ç”¨æ¸ é“çº¿è·¯`);
    console.log(`Base URL   : ${VENDOR_BASE_URL}`);
    options.baseUrl = VENDOR_BASE_URL;
  } else {
    console.log(`Routing    : ğŸŒ æ£€æµ‹åˆ°å®˜æ–¹ Key (AIzaå¼€å¤´) æˆ– é»˜è®¤è®¾ç½®ï¼Œä½¿ç”¨å®˜æ–¹çº¿è·¯`);
  }
  console.groupEnd();
  // --- DEBUG END ---

  return new GoogleGenAI(options);
};

export const generateDoorVisualization = async (
  coupletBase64: string, 
  doorStyle: string,
  doorBase64?: string | null
): Promise<string> => {
  const ai = getAI();
  const coupletData = stripBase64Prefix(coupletBase64);
  
  let contents: any[] = [];

  if (doorBase64 && doorStyle === "è‡ªå®¶å¤§é—¨") {
    const doorData = stripBase64Prefix(doorBase64);
    const prompt = `
      You are an expert product photographer and visual editor for an e-commerce store.
      Image 1 is a Chinese New Year couplet product (the merchandise).
      Image 2 is the target installation scene (a door).
      
      Task: Create a high-converting marketing image by realistically superimposing the couplet (Image 1) onto the door (Image 2).
      
      Requirements:
      1. **Sales Focus**: The couplet must look premium, high-quality, and clearly visible.
      2. Perspective & Lighting: Perfectly match the door's angle and environmental lighting.
      3. Placement: Adhere to traditional Chinese customs (vertical scrolls on sides, horizontal on top).
      4. Texture: Retain the texture of the couplet (e.g., velvet, gold stamping) to show quality.
    `;
    
    contents = [
      { inlineData: { mimeType: 'image/png', data: coupletData } },
      { inlineData: { mimeType: 'image/png', data: doorData } },
      { text: prompt }
    ];
  } else {
    const prompt = `
      You are an expert product photographer. 
      Task: Generate a high-quality lifestyle product shot of this Chinese New Year couplet pasted on a ${doorStyle}.
      
      Requirements:
      1. Atmosphere: Festive, warm, and inviting (Marketing style).
      2. Product Clarity: The couplet text and details must be sharp and readable to attract buyers.
      3. Composition: Professional framing suitable for social media ads.
      4. Realism: Natural shadows and material textures.
    `;
    
    contents = [
      { inlineData: { mimeType: 'image/png', data: coupletData } },
      { text: prompt }
    ];
  }

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash-image',
    contents: { parts: contents }
  });

  const parts = response.candidates?.[0]?.content?.parts;
  if (parts) {
    for (const part of parts) {
      if (part.inlineData && part.inlineData.data) {
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }
  }
  
  throw new Error("No image generated by the model.");
};

export const generateSocialCopy = async (
  titleTemplate: string,
  contentTemplate: string
): Promise<{ title: string; content: string }> => {
  const ai = getAI();

  const prompt = `
    You are a Senior Content Operations Specialist (èµ„æ·±ç”µå•†è¿è¥) for a Chinese New Year Couplet store.
    Your goal is to write high-converting social media copy (Xiaohongshu style) to SELL this product.

    Product Name/Title: "${titleTemplate}"
    Key Selling Points/Description: "${contentTemplate}"

    Requirements:
    1. **Target Audience**: Homeowners, young people looking for "ritual sense" (ä»ªå¼æ„Ÿ), or gift buyers.
    2. **Tone**: Enthusiastic, trustworthy, creating a sense of urgency (e.g., "High stock moving fast", "Premium quality").
    3. **Structure**:
       - **Headline**: Must be click-bait worthy (e.g., "My neighbors are asking where I bought this!", "Most beautiful couplet of 2024").
       - **Body**: Highlight material quality (flocking, gold stamping), the meaning of the text, and the visual upgrade to the home.
       - **Call to Action**: Soft sell (e.g., "Link in bio", "Comment for link").
    4. **Format**: Use relevant emojis (ğŸ§§, âœ¨, ğŸ ) and bullet points for readability.
    5. Output strictly valid JSON.
  `;

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash',
    contents: prompt,
    config: {
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          title: { type: Type.STRING },
          content: { type: Type.STRING }
        },
        required: ["title", "content"]
      }
    }
  });

  const jsonStr = response.text;
  if (!jsonStr) throw new Error("No text generated");
  
  try {
    return JSON.parse(jsonStr);
  } catch (e) {
    throw new Error("Failed to parse JSON response");
  }
};

export const extractInfoFromUrlContent = async (
  scrapedText: string
): Promise<{ title: string; content: string }> => {
  const ai = getAI();
  const context = scrapedText.slice(0, 30000); 

  const prompt = `
    ä½ æ˜¯ä¸€ä¸ªç”µå•†æ•°æ®åˆ†æå¸ˆã€‚è¯·åˆ†æä»¥ä¸‹ç½‘é¡µå†…å®¹ï¼Œæå–å•†å“çš„æ ¸å¿ƒè¥é”€ä¿¡æ¯ã€‚
    
    ç½‘é¡µåŸå§‹å†…å®¹ï¼š
    """
    ${context}
    """
    
    ä»»åŠ¡è¦æ±‚ï¼š
    1. æå–å•†å“ã€æ ‡å‡†åç§°ã€‘ä½œä¸ºæ ‡é¢˜ã€‚
    2. æå–ã€æ ¸å¿ƒå–ç‚¹ã€‘ï¼ˆå¦‚æè´¨ã€å·¥è‰ºã€å°ºå¯¸ã€å¯“æ„ï¼‰ä½œä¸ºå†…å®¹ï¼Œæ•´ç†æˆç®€æ´çš„è¥é”€çŸ­è¯­ã€‚
    3. è¿‡æ»¤æ‰æ— ç”¨çš„å¯¼èˆªã€ä¿ƒé”€å€’è®¡æ—¶ç­‰å¹²æ‰°ä¿¡æ¯ã€‚
    4. è¿”å› JSON æ ¼å¼ã€‚
  `;

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash',
    contents: prompt,
    config: {
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          title: { type: Type.STRING },
          content: { type: Type.STRING }
        },
        required: ["title", "content"]
      }
    }
  });

  const jsonStr = response.text;
  if (!jsonStr) throw new Error("No text generated");
  try { return JSON.parse(jsonStr); } catch (e) { return { title: "", content: "" }; }
};

export const extractInfoFromUrlViaSearch = async (
  url: string
): Promise<{ title: string; content: string }> => {
  const ai = getAI();

  const prompt = `
    Analyze this e-commerce URL: ${url}
    
    Task:
    1. Identify the Product Title.
    2. Summarize the Key Selling Points (features, benefits) in Chinese.
    
    Format as JSON: { "title": "...", "content": "..." }
  `;

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: { tools: [{ googleSearch: {} }] }
    });

    let text = response.text || "";
    text = text.replace(/```json/g, '').replace(/```/g, '').trim();
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    
    if (jsonMatch) {
      try { return JSON.parse(jsonMatch[0]); } catch (e) {}
    }
    if (text.length > 10) {
        return { title: "è‡ªåŠ¨æå–å•†å“å", content: text.substring(0, 300) };
    }
  } catch (error) {}

  return { title: "AI æ™ºèƒ½æå–ç»“æœ", content: "è¯·æ‰‹åŠ¨è¡¥å……å–ç‚¹ã€‚" };
};

export const generateCoupletVideo = async (image: string): Promise<string> => {
  const ai = getAI();
  const imageData = stripBase64Prefix(image);
  
  let operation = await ai.models.generateVideos({
    model: 'veo-3.1-fast-generate-preview',
    prompt: 'Professional product video, slow zoom in, high quality, 4k, showcasing the texture of the Chinese New Year couplet on the door.',
    image: {
      imageBytes: imageData,
      mimeType: 'image/png', 
    },
    config: {
      numberOfVideos: 1,
      resolution: '720p',
      aspectRatio: '9:16'
    }
  });

  while (!operation.done) {
    await new Promise(resolve => setTimeout(resolve, 5000));
    operation = await ai.operations.getVideosOperation({operation: operation});
  }

  const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
  if (!downloadLink) throw new Error("Failed to generate video URI.");

  return downloadLink;
};
